name: Build and Pre-release

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  check-trigger:
    runs-on: ubuntu-latest
    name: Check if build should trigger
    outputs:
      should-build: ${{ steps.check.outputs.should-build }}
    steps:
      - name: Check commit message or PR title
        id: check
        run: |
          SHOULD_BUILD="false"

          # Check commit message for push events
          if [ "${{ github.event_name }}" = "push" ]; then
            COMMIT_MESSAGE="${{ github.event.head_commit.message }}"
            echo "Commit message: $COMMIT_MESSAGE"
            if [[ "$COMMIT_MESSAGE" =~ ^[Bb][Uu][Ii][Ll][Dd]: ]]; then
              SHOULD_BUILD="true"
              echo "✅ Commit message starts with BUILD: or build:"
            else
              echo "❌ Commit message does not start with BUILD: or build:"
            fi
          fi

          # Check PR title for pull request events
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            PR_TITLE="${{ github.event.pull_request.title }}"
            echo "PR title: $PR_TITLE"
            if [[ "$PR_TITLE" =~ ^[Bb][Uu][Ii][Ll][Dd]: ]]; then
              SHOULD_BUILD="true"
              echo "✅ PR title starts with BUILD: or build:"
            else
              echo "❌ PR title does not start with BUILD: or build:"
            fi
          fi

          # Always build on manual trigger
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            SHOULD_BUILD="true"
            echo "✅ Manual workflow trigger - building"
          fi

          echo "should-build=$SHOULD_BUILD" >> $GITHUB_OUTPUT
          echo "Final decision: should-build=$SHOULD_BUILD"

  generate-version:
    runs-on: ubuntu-latest
    needs: check-trigger
    if: needs.check-trigger.outputs.should-build == 'true'
    name: Generate Version
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      summary: ${{ steps.summary.outputs.summary }}

    steps:
      - name: Checkout source code
        uses: actions/checkout@v5

      - name: Extract project version from version.txt
        id: version
        run: |
          # Read full version from version.txt
          if [ ! -f version.txt ]; then
            echo "version.txt not found" >&2
            exit 1
          fi
          VERSION=$(sed -n '1{s/\r$//;p}' version.txt | tr -d ' ') 
          if [ -z "$VERSION" ]; then
            echo "version.txt is empty" >&2
            exit 1
          fi
          echo "Version: $VERSION"
          
          # Check if tag already exists
          git fetch --tags || true
          if git rev-parse "refs/tags/$VERSION" >/dev/null 2>&1; then
            echo "❌ Error: Tag $VERSION already exists" >&2
            exit 1
          fi
          echo "✅ Tag $VERSION does not exist, safe to proceed"
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$VERSION" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate release summary from CHANGELOG
        id: summary
        run: |
          set -euo pipefail
          VERSION='${{ steps.version.outputs.version }}'
          BASE_MAJOR_MINOR="${VERSION%.*}"   # e.g. 2026.1 from 2026.1.1
          INCREMENT=".${VERSION##*.}"        # e.g. .1 from 2026.1.1
          echo "Searching for version: $VERSION (base: $BASE_MAJOR_MINOR, increment: $INCREMENT)"
          if [ ! -f CHANGELOG.md ]; then
            echo "summary=# $VERSION" >> $GITHUB_OUTPUT
            exit 0
          fi
          # Find changelog entry matching major.minor, then increment
          awk -v base_ver="$BASE_MAJOR_MINOR" -v inc="$INCREMENT" -v ver="$VERSION" '
          BEGIN{foundMM=0;foundInc=0} 
          {
            # Match major.minor header exactly
            if ($0 == "# " base_ver) {
              foundMM=1
              print "Found major.minor header: " $0 > "/dev/stderr"
              next
            }
            # Exit if we hit another major header
            if (foundMM && $0 ~ /^# / && $0 != "# " base_ver) {
              print "Hit new major header, exiting: " $0 > "/dev/stderr"
              exit
            }
            # Match increment header exactly  
            if (foundMM && $0 == "## " inc) {
              foundInc=1
              print "Found increment header: " $0 > "/dev/stderr"
              next
            }
            # Process content in increment section
            if (foundInc) {
              if ($0 ~ /^## /) {
                print "Hit new increment header, stopping: " $0 > "/dev/stderr"
                foundInc=0
                next
              }
              if ($0 ~ /^# /) {
                print "Hit new major header, exiting: " $0 > "/dev/stderr"
                exit
              }
              if ($0 ~ /^-/) {
                print "Adding line: " $0 > "/dev/stderr"
                print $0
              }
            }
          }' CHANGELOG.md > /tmp/summary.txt
          if [ -s /tmp/summary.txt ]; then
            # Create formatted summary with version header and preserve list structure
            echo "# $VERSION" > /tmp/formatted_summary.txt
            cat /tmp/summary.txt >> /tmp/formatted_summary.txt
            # Create proper JSON with \r\n sequences
            SUMMARY=""
            first_line=true
            while IFS= read -r line; do
              escaped_line=$(echo "$line" | sed 's/%/%25/g')
              if [ "$first_line" = true ]; then
                SUMMARY="$escaped_line"
                first_line=false
              else
                SUMMARY="$SUMMARY$(printf '\r\n')$escaped_line"
              fi
            done < /tmp/formatted_summary.txt
            echo "Summary extracted:"
            cat /tmp/formatted_summary.txt
            echo "summary=$SUMMARY" >> $GITHUB_OUTPUT
          else
            echo "No matching changelog entries found for $VERSION; fallback to version header only"
            echo "summary=# $VERSION" >> $GITHUB_OUTPUT
          fi

  build-firmware:
    name: Build Firmware
    needs: [check-trigger, generate-version]
    if: needs.check-trigger.outputs.should-build == 'true'
    uses: DoYouHost/workflows/.github/workflows/build.yml@main
    with:
      files: |
        esp32-carb-o-nated.yml
      esphome-version: "2026.1.2"
      combined-name: Carb-O-nated
      release-version: ${{ needs.generate-version.outputs.version }}
      release-summary: ${{ needs.generate-version.outputs.summary }}
      release-url: "https://github.com/DoYouHost/Carb-O-nated/releases/tag/${{ needs.generate-version.outputs.tag }}"
      debug: false

  upload-to-pre-release:
    name: Upload to Pre-Release
    uses: DoYouHost/workflows/.github/workflows/upload-to-gh-release.yml@main
    needs:
      - build-firmware
      - generate-version
    with:
      version: ${{ needs.generate-version.outputs.version }}
      description: ${{ needs.generate-version.outputs.summary }}
      prerelease: true
    secrets:
      PAT_TOKEN: ${{ secrets.DOYOUHOST_PAT }}

  upload-to-r2:
    name: Upload to R2
    uses: DoYouHost/workflows/.github/workflows/upload-to-r2.yml@main
    needs:
      - build-firmware
      - generate-version
    with:
      directory: Carb-O-nated
    secrets: inherit

  promote-to-beta:
    name: Promote to Beta
    uses: DoYouHost/workflows/.github/workflows/promote-r2.yml@main
    needs:
      - build-firmware
      - generate-version
      - upload-to-r2
    with:
      version: ${{ needs.generate-version.outputs.version }}
      directory: Carb-O-nated
      channel: beta
      manifest-filename: manifest-beta.json
    secrets: inherit
